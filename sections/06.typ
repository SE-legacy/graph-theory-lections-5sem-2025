// Hi, babies!
// NOTE: Лекция 6. 10.10.2025

// fun aboba (hda :: tla, b, c) =
//       case optionalFun (hda, b, 0)
//         of SOME result => SOME (resultOperation result)
//          | _           => optionalFun (tla, b, c)
//   | aboba _ = NONE      

/ Удтверждение: Ребро $e = (x, y)$ в простом связном графе $G$ является мостом
  $<=>$ $e$ не принадлежит ни одному из циклов графа $G$.

*Доказательство:*
+ Пусть $e$ --- мост.

  По определению удаление $e$ привдодит к появлению в графе $G-е$ хотябы одной 
  пары $u, v$ не связанных между собой вершин

  // FIX: рисунок 1

  В исходном графе $G$ эти вершины связаны между собой простым путем $P = 
  (u, dots, v)$, который с необходимостьюпроходит через $e = (x, y)$. В графе $G-e$
  вершины $u$ и $x$ связаны между собой участком $(u, dots, x)$ пути $P$, а
  вершины $y$ и $v$ участком $(y, dots, v)$ пути $P$.

  Если бы ребро $e$ принадлежало циклу $C$ в графе $G$, то $x$ и $y$ оказались
  бы связанными в графе $G-e$ путём $C-e$. Но тогда связанными бы оказались
  и вершины $u, v$. Противоречие.

+ Пусть $e = (x, y)$ не принадлежит ни одному из циклов графа $G$.
  Предположим, что $e$ не является мостом, то есть его удаление оставляет
  граф $G-e$ связным.

  Тогда $x$ и $y$ в графе $G-e$ связанные (путём $P$).

  Добавим к нему ребро $e$, получим цикл. Противоречие.

*Домашнее задание:*

// TODO: написать

= Алгоритмы обходов

// "Это база" (c) Огнёва
// :)
// А она называла кто должен дз показать?
// хз

== Обход в глубину

=== Рекурсивный обход

Массив `used[1:n]`

Граф задается списками смежности `Adj[v]`

До начала работы алгоритма

```python
for v in V:
  used[v] = 0
```

```python
def dfs(v):
  used[v] = 1
  for u in Adj[v]:
    if not used[u]:
      dfs(u)
```

Для несвязного графа зпускается в цикле:

```python
for v in V:
  if not used[u]:
    dfs(v)
```

=== Нерекурсивный обход


```python
def dfs(v):
  used[v] = 1
  push(s, v)
  while not empty(s):
    top(s, u)
    if (exists w in Adj[u]: used[w] = 0):
      used[w] = 1;
      push(s, w);
    else:
      pop(s)
```

// Сраный supermaven, если я хочу просто таб нажать, он иногда мне автокомплит ебенит
// блять, жиза нахуй, надо хоткей другой поставить
// Не, мне другой не удобно
// пупупу

```python
def dfs(v):
  used[v] = 1
  push(s, v)
  while not empty(s):
    top(s, u)
    pop(s)
    for w in Adj[u]:
      if not used[w]:
        used[w] = 1
        push(s, w)
```
=== Обход в глубину (три цвета)
Цвета вершин -- белый, серый, черный (массив color)
Метки времени ($d$ --- вершина $u$ --- открывается (становится серой),
$f$ --- вершина $u$ закрывается (становится чёрной)).

Массив предшественников

*DFS(G)*:
```python
for для каждой вершины u in V[G]:
  do color[u] = WHITE
    pi[u] = nil
time = 0
for для каждой вершины u in V[G]:
  do if color[u] = WHITE
    then DFS_Visit(u)

```

*DFS_Visit(u)*:
```python
color[u] <- GRAY                    # Открыта белая вершина u
time <- time + 1
d[u] <- time

for для каждой вершины v in Adj[u]  # Исследование ребра (u, v)
  do if color[u] = WHITE
     then pi[v] <- u
          DFS_Visit(v)

color[u] <- BLACK                   # Завершение
f[u] <- time <- time + 1
```

=== Подграф предшествования
Рассмотрим подграф предшествования обхода в глубину $G_n = (V, E)$...

// TODO: Переписать фотки у Шефа

== Обход в ширину

=== Два цвета
```python
def bfs(v):
  used[v] = 1
  push(q, v)
  while not empty(q):
    pop(q, u)
    for w in Adj[u]:
      if not used[w]:
        used[w] = 1
        push(q, w)
```


=== Три цвета
*BFS(G, s)*
```python
for для каждой вершины v in V[G] - s:
  do color[u] <- WHITE
    d[u] <- infinity
    pi[u] <- NIL

color[s] <- GRAY
d[s] <- 0
pi[s] <- NIL
Q <- empty
Enqueue(Q, s)

while Q not = []
  do u = Dequeue(Q)
    for для каждой u in Adj[u]
      do if color[v] = WHITE
          then color [v] = GRAY
                d[v] = d[u] + 1
                pi[v] = u
                Enqueue(Q, v)
    color[u] = BLACK

```

// FIX: рисунок 2 (у Шефа)

#table(
  columns: (auto, auto, auto),
  [*used*],                   [*стек*],         [*экран*],
  $0, 0, 0, 0, 0, 0, 0, 0$,   [пусто],        [пусто],
  $1, 0, 0, 0, 0, 0, 0, 0$, $1$,            $1$,
  $1, 1, 0, 0, 0, 0, 0, 0$, $2, 1$,         $1, 2$,
  $1, 1, 1, 0, 0, 0, 0, 0$, $3, 2, 1$,      $1, 2, 3$,
  $1, 1, 1, 0, 0, 0, 0, 0$, $2, 1$,         $1, 2, 3$,
  $1, 1, 1, 1, 0, 0, 0, 0$, $4, 2, 1$,      $1, 2, 3, 4$,
  $1, 1, 1, 1, 1, 0, 0, 0$, $5, 4, 2, 1$,      $1, 2, 3, 4, 5$,
  $1, 1, 1, 1, 1, 1, 0, 0$, $6, 5, 4, 2, 1$,      $1, 2, 3, 4, 5, 6$,
  $1, 1, 1, 1, 1, 1, 1, 0$, $7, 6, 5, 4, 2, 1$,      $1, 2, 3, 4, 5, 6, 7$,
  $1, 1, 1, 1, 1, 1, 1, 0$, $6, 5, 4, 2, 1$,      $1, 2, 3, 4, 5, 6, 7$,
  $1, 1, 1, 1, 1, 1, 1, 0$, $5, 4, 2, 1$,      $1, 2, 3, 4, 5, 6, 7$,
  $1, 1, 1, 1, 1, 1, 1, 0$, $4, 2, 1$,      $1, 2, 3, 4, 5, 6, 7$,
  $1, 1, 1, 1, 1, 1, 1, 0$, $2, 1$,      $1, 2, 3, 4, 5, 6, 7$,
  $1, 1, 1, 1, 1, 1, 1, 0$, $1$,      $1, 2, 3, 4, 5, 6, 7$,
  $1, 1, 1, 1, 1, 1, 1, 1$, $8, 1$,      $1, 2, 3, 4, 5, 6, 7, 8$,
  $1, 1, 1, 1, 1, 1, 1, 1$, $1$,      $1, 2, 3, 4, 5, 6, 7, 8$,
  $1, 1, 1, 1, 1, 1, 1, 1$, [пусто],      $1, 2, 3, 4, 5, 6, 7, 8$,
)


// FIX: рисунок 2 (у Шефа)
#table(
  columns: (auto, auto, auto),
  [*used*],                   [*очередь*],         [*экран*],
  $0, 0, 0, 0, 0, 0, 0, 0$,   [пусто],             [пусто],
  $1, 0, 0, 0, 0, 0, 0, 0$,   $1$,                 $1$,
  $1, 1, 0, 0, 0, 0, 0, 1$,   $2, 8$,              $1, 2, 8$,
  $1, 1, 1, 1, 0, 0, 1, 1$,   $8, 3, 4, 7$,        $1, 2, 8, 3, 4, 7$,
  $1, 1, 1, 1, 0, 0, 1, 1$,   $3, 4, 7$,           $1, 2, 8, 3, 4, 7$,
  $1, 1, 1, 1, 0, 0, 1, 1$,   $4, 7$,              $1, 2, 8, 3, 4, 7$,
  $1, 1, 1, 1, 1, 0, 1, 1$,   $7, 5$,              $1, 2, 8, 3, 4, 7, 5$,
  $1, 1, 1, 1, 1, 1, 1, 1$,   $5, 6$,              $1, 2, 8, 3, 4, 7, 5, 6$,
  $1, 1, 1, 1, 1, 1, 1, 1$,   $6$,                 $1, 2, 8, 3, 4, 7, 5, 6$,
  $1, 1, 1, 1, 1, 1, 1, 1$,   [пусто],             $1, 2, 8, 3, 4, 7, 5, 6$,
)

*Домашнее задание:*\
Сделать аналогичные таблицы на этом графе для 3 цветов

// трасса для гонок между курсорами
// я заебался в запятые врезаться
// :)

= Способы компьютерного представления графа

== Матрица смежности
$
A_(i j) = cases(
  1\, exists(i, j), 
  0\, exists.not (i, j)
)
$

Преимущество в том, что можно за $O(1)$ определить, являются ли две вершины
смежными. Однако, если матрица смежности слишком разреженная, при этом
граф большой, то память расходуется слишком неэкономно (всегда $O(n^2)$).

== Список смежности

$forall #[вершины] exists #[список смежных вершин]$

Сложнее определять, являются ли вершины смежными, однако хранится оптимальнее.

== Списки ребер (списки инцеденции)

== Матрица весов

== Матрица инцидентности

*Домашнее задание:*

Зачем нужна такая матрица?
== Матрица Киргофа
*Домашнее задани:*

Выписать матрицу и зачем она нужна


// я ща усну нахуй... 
// TODO: Сильно закрой глаза на 20 секунд
// Живи
// кофе внутривенно срочно
// Могу чай предложить)
// я после пары кофейку себе куплю, пофиг
// ок
