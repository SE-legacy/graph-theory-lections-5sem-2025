// NOTE: Лекция 9. 31.10.2025

// NOTE: ЧИИИИИИИИИИФ :)
= Алгоритм Дейкстры: поиск кратчайших путей от одной вершины.

- Задача: Дан взвешенный граф $G = (V, E)$. Веса ребере $w(u, v) >= 0$
  (неотрицательные) Найти кратчайшие пути от заданной исходной вершины s до
  всех остальных вершин графа.

== Необходимые определения
- *Вес пути*: Сумма весов всех ребер, входящих в этот путь.
- *Кратчайший путь $(p(s, v))$*: путь минимально возможным весом из $s$ в $v$.
- *Массив dist[]*, где dist[v] --- длина кратчайшего пути из $s$ в $v$.
- *Массив pred[]*, позволяющий восстанавливать сам путь.
- *Операция "Релаксации"*: Освновкая операция
  - Имеем: текущая оценка расстояния до $v$ --- dist[v]
  - Рассматриваем ребро (u, v).
  - Если $#[dist] [u] + w(u, v) < #[dist] [v]$, то мы нашли более короткий путь через $u$
  - Обновляем: $#[dist] [v] = #[dist] [u] + w(u, v)$ и $#[prev] [v] = u$.

== Описание алгоритма
+ Для всех вершин установить, что они еще не посещены, $#[dist] [v] = $.
  Для вершины, с которой начинается поиск, $#[dist] [s] = 0$.
+ Пока есть не посещённые вершины:
  - Выбрать вершину u с минимальным значением $#[dist] [u]$ среди непосещённых.
  - Пометить u как посещённую. (Её $#[dist] [u]$ теперь окончателен)
  - Для каждого соседа $v$ вершины $u$ релаксировать ребро $(u, v)$.

== Псевдокод Алгоритма
// FIX: код

== Доказательство корректности алгоритма
Докажем по индукции, что в момент посещения любой вершины $u, #[dist] [u]=ρ(s,u)$

*База индукции:*  На первом шаге выбирается *s*, для неё выполнено: $d(s)=ρ(s,s)=0$

*Шаг:* Пусть для n первых шагов алгоритм сработал верно и на $n+1$ шагу выбрана
вершина u. Докажем, что в этот момент $#[dist] [u]=ρ(s,u).$
Для начала отметим, что для любой вершины v, всегда выполняется
$#[dist] [v] gt.eq ρ(s,v).$

Пусть $P$ --- кратчайший путь из $s$ в $u$, $v$ --- первая непосещённая вершина
на $P$, $z$ --- предшествующая ей (следовательно, посещённая). Поскольку
путь $P$ кратчайший, его часть, ведущая из $s$ через $z$ в $v$, тоже кратчайшая,
следовательно $ρ(s,v)=ρ(s,z)+w(z, v)$

По предположению индукции, в момент посещения вершины $z$ выполнялось
$#[dist] [z]=ρ(s,z)$, следовательно, вершина $v$ тогда получила метку не
больше чем

$#[dist] [z] + w(z v) = ρ(s, z) + w(z v)=ρ(s, v)$, следовательно,
$#[dist] [v] = ρ(s,v)$.

С другой стороны, поскольку сейчас мы выбрали вершину u, её метка
минимальна среди непосещённых, то есть
$
#[dist] [u] lt.eq #[dist] [v]=ρ(s,v) lt.eq ρ(s,u)
$
, где второе неравенсто верно из-за ранее упомянутого определения вершины $v$ в
качестве первой непосещённой вершины на $P$, то есть вес пути до промежуточной
вершины не превосходит веса пути до конечной вершины вследствие
неотрицательности весовой функции

Комбинируя это с $#[dist] (u) gt.eq  ρ(s,u)$ , имеем $#[dist] (u)=ρ(s,u)$, что и
требовалось доказать.
== Пример работы Алгоритма
// FIX: картинки с презы

// NOTE: САНЯЯЯЯЯ :)
= Алгоритм Флойда-Уоршелла (Поиск кратчайших путей между всеми парами вершин.)
== Постановка общей задачи
*Проблема:* Дан взвешенный граф. Необходимо найти кратчайшие пути между
вершинами.

*Ключевые вопросы:*

Из одной вершины:
+ Найти кратчайшие пути от одной выделенной вершины до всех остальных.
+ Между всеми парами: Найти кратчайшие пути от каждой вершины до каждой.

== Необходимо обговорить:
- Важно: Алгоритм Флойда-Уоршелла работает с ориентированными и
  неориентированными графами. Допускает отрицательные веса, но не допускает
  циклов отрицательного веса.
- Граф будет взвешанный

== Просто интересно:
Теоремы:
- Алгоритм Флойда-Уоршелла позволяет находить кратчайшие пути между всеми парами
  вершин за $O(|V|^3)$
- Если в графе есть отрицательный цикл, то кратчайшие пути между некоторыми
  вершинами не существуют.

== Алгоритм
*Вход:* Матрица смежности $W$ размером $n times n$, где:
- $W[i][j] = w(i, j)$ --- вес ребра $(i, j)$, если оно существует
- $W[i][j] = infinity$ --- если ребра нет
- $W[i][j] = 0$ --- расстояние от вершины до самой себя

*Выход:* Матрица $D$ размером $n times n$, где $D[i][j] = d(i, j)$ --- длина
кратчайшего пути из $i$ в $j$

(Необязательно) Матрица предшествования $P$ для восстановления самих путей.

== Псевдокод
```
for k in range(n):
    for i in range(n):
        for j in range(n):
            if dist[i][k] + dist[k][j] < dist[i][j]:
                dist[i][j] = dist[i][k] + dist[k][j]
```


Сложность: $O(|V|^3)$ (три вложенных цикла)
Память: $O(|V|^2)$

== Пример работы
// FIX: картинки с презы

== Домашнее задание
Определить матрицу кратчайших путей алгоритмом Флойда-Уоршелла для графа,
определённого матрицей ниже:

$mat(
  0, 3, infinity, 7;
  8, 0, 2, infinity;
  5, infinity, 0, 1;
  2, infinity, infinity, 0
)$


// NOTE: ДАНЯЯЯЯЯ :)
= Остовные деревья

Обычно нам нужно добраться из любой вершины в любую другую и использовать как
можно меньше ребер. При этом часто возникает проблема поиска связного подграфа
графа, в котором используется как можно меньше ребер. Чтобы избежать этой
проблемы, нужно использовать связные деревья.

Рассмотрим следующую задачу:

- Авиакомпания содержит $m$ рейсов между $n$ городами, $i$-ый из них обходится в $w_i$
  рублей, причём из любого города можно добраться до любого другого. В стране
  наступил кризис, и нужно отказаться от как можно большего числа из них таким
  образом, что содержание оставшихся рейсов будет наиболее дешёвым.

// FIX: картинк1 с juppiter

Иными словами, нужно найти дерево минимального веса, которое является подграфом
данного неориентированного графа. Почему дерево? Потому что в противном случае
там был бы цикл, из которого можно удалить какое-то ребро и получить более
оптимальный ответ. А если это больше, чем одно дерево, то какие-то две вершины
остаются несвязны.

Такие деревья называют остовами (каркас, скелет; ударение на первый слог, но так
мало кто произносит; англ. minimum spanning tree --- дословно, минимальное
покрывающее дерево).

*Формально:*
- Остовное дерево (англ. spanning tree) графа $G=(V,E)$ --- ациклический связный
  подграф данного связного неориентированного графа, в который входят все его
  вершины.
- Минимальное остовное дерево (англ. minimum spanning tree) графа $G=(V,E)$ ---
  это его ациклический связный подграф, в который входят все его вершины,
  обладающий минимальным суммарным весом ребер.

// TODO: ДАНЯ Я ОПУХНУ ТЕБЯ КОСПЕКТИРОВАТЬ
