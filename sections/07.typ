// NOTE: Лекция 7. 17.10.2025
= Поиск компонента связности

*Алгоритм:*
+ Запустить BFS/DFS из любой непосещенной вершины --- по окончании получить 
  компоненту связности: ее составляют все посещенные вершины.
+ Если остались непосещенные --- вершнуться к шагу 1.


```
dfs(v) {
  components = []
  used[v] = TRUE
  s.push(v)
  components.push_back(v)

  while (~s.empty()) {
    u = s.top()
    found_not_wisited = FALSE
      for (w in Adj[u]) {
        if (!used[w]) {
          found_not_visited = TRUE
          used[w] = TRUE
          s.push(w)
          components.push_back(w)
          break
        }
      }
    }
  }
}
```
Сложность алгоритма $O(V + E)$
```

```
// TODO: Есть на фото

// FIX: картинка 1


= Поиск кратчайших путей в незвешенном графе
*Длина* пути = число ребер

*Задача*: найти кратчайший путь из $s$ в $f$

*Алгоритм*:
+ Хранить массив $d i s t[u]$ растояний от $s$ до $u$. Запуститт BFS из $s$
+ обновлять $d i s t[u]$ соседей текущей вершины: $d i s t[#[соседа]] = d i s t[#[текущей]] + 1$
+ Остановить, когда встрети $f$.

*Почему обход в ширину?*
// TODO: 

```
bfs_shortest(s, f) {
  for (v in V) {
    used[v] =FALSE
    dist[v] = INFINITY
    parents[v] = NULL
  }
  used[s] = TRUE
  dist[s] = 0
  q.push(s)
  while(~q.empty()){
    u = q.front()
    q.pop()
    if (u == f){
      return (dist[u], parents)
    }
    for (w in Adj[u]) {
      if(!used[w]){
        used[w] = TRUE
        dist[w] = dist[u] + 1
        parents[w] = u
        q.push(w)
      }
    }
  }
}
```

Сложность алгоритма $O(V + E)$
// FIX: картинка 2

*ДЗ*
Найти кратчайший путь от 8 до 9

= Построение остовного дерева
/ Остовное дерево: --- подграф данного связного неориентированного граф, который
  является дерево (= ациклический и связный) и содержит все вершины графа.

Дерево на $n$ вершинах всегда содержит $(n - 1)$ ребро $=>$ в отличие от 
взвешенного граф, ищем неминимальное (они все "равны"), а любое остовное дерево.

Если граф несвязный, можно построить *остовный лес* --- объединение остовныъ 
деревьев компонент связности.

== Алгоритм
Просйти любым обходом (в глубину/в ширину), сохраняя ребра, по которым шли.

Ребра, в зависимости от задачи, можно хранить явно или в виде массива предков.

Если граф связный, то дерево обхода будет остовным, т.к.
+ содержит все врешины
+ не содержит циклов (каждую вершину посетили ровно 1 раз)

Если граф несвязный, запускать обход для каждой компоненты связности, пока не 
закончатся непосещенные вершины. Получим остовный лес.

```
find_spanning_tree(v) {
  parents = []
  for (v in V)
    parents[v] = NULL
  used[v] = TRUE
  s.push(v)

  while (!s.empty()) {
    u = s.top()
    found_not_visited = FALSE
    
    for (w in Adj[u]) {
      if (!used[w]) {
        found_not_visited = TRUE
        used[w] = TRUE
        s.push(w)
        parents[w] = u
        break
      }
    }
  }
}

find_forest {
  for (v in V) {
    used = FALSE
  }

  forest = []

  for (v in V) {
    if (!used[v]) {
      tree = find_spanning_tree(v)
      forest.push_back(tree)
  }
}
```

#table(
  columns: (auto, auto, auto, auto),
  [stack],  [used],       [par],      [depth],
  $1$,      $100000000$,  $-$,        $000000000$,
  $21$,     $110000000$,  $(2, 1)$,   $010000000$,
  $821$,    $110000010$,  $(8, 2)$,   $010000020$,
  $4821$,   $110100010$,  $(8, 2)$,   $010300020$,
) // TODO: есть фотка

= Фундаментальные циклы

$F_2 = {0, 1}$ --- поле, где определены операции сложения по модулю $2$ и 
умножения.

Пусть дан граф $G = (V, E)$, $| E | = m$. Множества ребер его подграфов можно 
описать вектором $z in FF_2^m$ длины $m$, в котором координата $x_i$ 
соответствует ребру и равна $0$, если ребра нет в подграфе, и 1, если оно есть.

_Сумма (по модулю 2) таких векторов = симметрическая разность множеств ребер._

Рассмотрим подграф, в котором каждая вершина имеет четную степень. 
Соответствующий ему вектор назыают *циклическим*.

Более формально: *циклический вектор* --- это 1-цепь с границей 0.

*1-цепь* --- линейная комбинация ребер: $sum epsilon_i x_i, epsilon_i in {0, 1}$

Граница 1-цепи = сумма входящих в нее вершин (по модулю 2). Т.е. если вершина
входит в нее четное чило раз, она "обнуляется".
Граница 0 означает, что каждая вершина встретилась четное число раз.

*Утверждение.* Множество циклических векторов образует векторное пространство 
$CC$ на $F_2 = {0, 1}$, называемое *циклическим*

*Доказательство*

Рассмотрим сумму двух циклических векторов $Z_1, Z_2$ = симметрическую разность
соответствующих подграфов $G_1, G_2$ Вершины этих подграфов имеют четные степени
по определению циклического вектора. Пусть $G = G_1 Delta G_2$.

Тогда для любой вершины $v$:
$
#[deg]_G (v) = #[deg]_G_1 (v) + #[deg]_G_2 (v)
$// TODO:

/ Фундаментальный цикл: графа $G$ относительно остова $T$ --- простой цикл, $C$
полученный путем допбавления к остову $T$ ребра $x in.not T$

*Теорема:*

Множество всех фундаментальных циклов отсносительно любого остова $T$ графа $G$
образует базис циклического пространства этого графа.

*Доказательство:*

Линейная независимость:

Выделим остов $T$ и все фнудаментальные циклы относительно него $C_1, dots, C_5$
Каждый цикл получен добавлением одного ребра к остову $=>$ хотя бы одно ребро в
каждом уникально, и// TODO:

Докажем, что любой циклический вектор можно выразить через фунадментальные циклы.
Пусть $Z$ --- произвольный подграф, соответствующий некторому циклическому вектору.
Ребра $e_1, dots, e_k$ принадлежат $Z$, но не принадлежат $T$. Обозначим через 
$C_1, dots, C_k$ фундаментальные циклы, которые содержат ребра $e_1, dots, e_k$
соответственно.

Рассмотрим граф  $F$ --- сумму $Z$ и $C_1, dots, C_k$ Повторяющиеся ребра $e_1,
dots, e_k$ четны (т.к. это циклические векторы), тогда степени всех вершин $F$
четны. Если $F$ не пустоф, тогда он содержит  $=> T$ содерижт циклы и получаем 
противречие $=> F$ пустой

// TODO: формула

*Фундаментальный цикл $eq.not$ минимальный цикл*
// FIX: картинка 4


/ Опр: Пусть вршины графа разбиты на два множества. *Разрезом* будем называть
  набор всех ребер графа, концевые вершины которых находятся по разные стороны 
  разбиения.

Если $S subset.eq V$, то разрез, определяемый этим подмножеством:
$
  {(u, v) in E : u in S, v in.not S}
$

Множество разрезов образует векторное пространство над $FF_2 = {0, 1}$ называемое
*протранством разрезов* (или *пространством коциклов*).

Если удалить ребро из остова, он распадается на две компоненты

/ Коцикл графа $G$:относительно остова $T$ --- это подможножество ребер графа,
  которое соединяет получившиеся компоненты

*Теорема:*

множество всех коциклов относительно любого остова $T$ графа $G$ образует базис
базис пространства коциклов этого графа.

== Связь с матрицей инцидентности
/ Матрицей инцидентности: графа называется матрица $I(|V| times |E|)$ для которой
- $I_(i j) = 1$, если вершина $v_i$ инцидентна ребру $e_j$,
- $I_(i j) = 0$ в остальных случаях.

Матрица инцидентности задает отображение из пространства ребер в пространставо 
вершин

$r a n k(I) = n - k$ --- число ребер остовного леса


/ Ядро матрицы: --- множество всех векторов, которые при умножении на матрицу
дают нулевой вектор.

*Циклическое векторное пространство --- это ядро матрицы инцидентности:*

$
CC = #[Ker] (I)
$


*Теорема (размерность циклического пространства)*

Для графа с числом вершин $n$ ребер $m$ и компонент связности $k$ размерность
циклического пространства $#[dim]$ // TODO: дописать из презы
