// NOTE: Лекция 8. 24.10.2025

Транспонированная матрица инцидентности задает отображение из пространства 
вершин в пространство ребер.

/ Образ матрицы: --- это множество всех векторов, которые можно записать как
  линейную комбинацию ее столбцов.

/ Пространство коциклов: --- это образ транспонированной матрицы инцидентности:
  пространство коциклов $= I m (B^T)$

Размерность проастранство коциклов = число коциклов = число ребер остовного леса
\= $n -k$

Пространства циклов и коциклов ортогональны, т.е. скалярное произведение любого
элемента первого пространства на элемент второго равно 0:
$
forall x in C(G), space y in C u t(G) : x y = limits(sum)_(e in E) x_e y_e = 0
$

*Что это значит?*

Сумма по модулю $2 = 0 =>1$ встретилось четное число раз. Произведение координат
равно $1 =>$ они обе равны $1 =>$ соответствующее ребро --- общее для подграфов.

То есть: ортогональность = в пересечении любого цикла и любого разреза четное 
число ребер.

/ Матрица Кирхгофа графа $G$: называется матрица $K (|V| times |V|)$, элементы
  которой определяются равенством:
$
k_(i j) = cases(
  d e g (v_i)\, space i = j,
  -1\, (v_i, v_j) in E,
  0\, #[otherwise]
)
$

Пусть $G$ --- произвольный граф. Превратим каждое ребро в дугу (произвольно).
Полученный орграф будем называть *ориентацией* графа $G$.

/ Лемма: Пусть $K$ --- матрица Кирхгофа граф $G$, $I$ --- матрица инцидентности
  $G$ с некоторой ориентацией. Тогда $K = I dot I^T$.
/ Теорема: Число остовов в связном неодноэлементном графе $G$ равно 
  алгебраическому дополнению любого элемента матрицы Кирхгофа.

$
mat(delim: "|",
  4, -1, -1, -1, 0, 0, 0, 0, -1;
  -1, 2, 0, 0, 0, 0, 0, -1, 0;
  -1, 0, 2, 0, 0, 0, 0, 0, -1;
  -1, 0, 0, 5, -1, -1, -1, -1, 0;
  0, 0, 0, -1, 2, 0, 0, -1, 0;
  0, 0, 0, -1, 0, 1, 0, 0, 0;
  0, 0, 0, -1, 0, 0, 2, 0, -1;
  0, -1, 0, -1, -1, 0, 0, 3, 0;
  -1, 0, -1, 0, 0, 0, -1, 0, 3;
)
$

== Алгоритм поиска фундаментальных циклов
+ По алгоритму, рассмотренному ранее, построить остовное дерево.
+ Для всех ребер $(u, v)$, не вошедших в остов:
  - найти простой путь от $u$ до $v$ в остове
  - добавить к нему $(u, v)$ --- это и будет функдаментальный цикл

Самый простой вариант посика пути от $u$ до $v$ --- обход остова.
Алгоритм можно оптимизировать, если при первом обходе (при построении остова)
сохранять $#[parents] [v]$ и $#[depths] [v]$, а затем искать *Lowest Common 
Ancstor (LCA)* --- самого глубого общего предка вершин.

Остов будет представлен массивом parents[]. Циклы удобно хранить как бинарные векторы длины $m$, тогда находить симметрическую разность можно с помощью XOR.


// NOTE: Лекция Насти

= Алгоритмы обходов графов... // TODO: 
== Проверка графа на двудольность
*Задача:* определить, является ли заданный неориентированныйграф двудольным.

- Двудольный граф (бипартитный) --- граф, вершины которого мо... // TODO: 

// TODO:
// FIX: рисунок 1 (с примером)

```
для каждой вершины v in V(G) выполнить
  цвет[v] <- НЕОПРЕДЕЛЕН
конец для
для каждой вершины s in V(G) выполнить
  если цветх[s] = НЕОПРЕДЕЛЕН тогда
    цвет[s] <- 1
    СОЗДАТЬ очередь Q
    ДОБАВИТЬ S в Q
    пока Q не пуста выполнить
      v <- удалить_из_начала(Q)
      Для каждого соседа u вершины v выполнить
        если цвет[u] = НЕОПРЕДЕЛЕН тогда
          цвет[u] <- 3 - цветх[v] // противоположный цвет
          Добавить u в Q
        иначе если цвет[u] = цветх[v] тогда
          вернуть ЛОЖЬ // Граф не двудольный
        конец если
      конец для
    конец пока
  конец если
конец для
вернуть ИСТИНА // Граф двудольный
```



#table(
  columns: (auto, auto),
  [очередь], [цвета],
  $-$, [нннннн],
  $1$, [1ннннн],
  $2$, [12нннн],
  $3, 4$, [1211нн],
  $4, 5$, [12112н],
  $5, 6$, [121122],
  $6$, [1211222],
)

Давайте посмотрим на этот алгоритм с другой стороны.
/ Теорема Кенига: граф двудольный $<=>$ не содержит циклов нечетной длины.

== Проверка на цикличность

```
функция dfs(u, p)
  состояние[u] <- 
```

#table(
  columns: (auto, auto),
  [очередь], [цвета],
  $-$, $0 0 0 0 0 0$,
  $1$, $1 0 0 0 0 0$,
  $2, 1$, $1 1 0 0 0 0$,
  $3, 2, 1$, $1 1 1 0 0 0$,
  $5, 3, 2, 1$, $1 1 1 0 1 0$,
  $4, 5, 3, 2, 1$, $1 1 1 1 1 0$,
  $2, 4, 5, 3, 2, 1$, $1 1 1 1 1 1$,
)

В этой задаче мы обознчали статус вершины как НЕ_ПОСЕЩЕНА, В_СТЕКЕ, ОБРАБОТАНА.

// NOTE: Лекция Вики

= Алгоритм Форда-Беллмана (взвешенные графы)

*Цель* Найти кратчайшие пути от выбранной вершины до всех остальных вершин графа.

*Особенность* Работает с ребрами, имеющие отрицатиельные и неотрицательные веса.

/ Алгоритм Форда-Беллмана: --- алгоритм поиска кратчайшего пути во взвешенном графе
  Допускает ребра с отрицательными весами

*Класс решаемых задач:* Дан орентиро

/ Опр: Цикл, сумма весов ребре которого отрицательна, называется отрицательным 
  циклом.

/ Лемма: Если в графе нет циклов отрицательной длины, то кратчайший путь между 
  любыми вумя вершинами содержит не более $|V| - 1$ ребер, где $|V|$ --- 
  количество вершин в графе.

```
// Заполнение начальными значениями
for v in V
  do d[v] <- + inf
d[s] <- 0

// |V| - 1 итерация
for i <- 1 to |V| - 1
  do for (u, v) in E
    if d[v] > d[u] + w(u, v)
      then d[v] <- d[u] + w(u, v)

// Проверка на отрицательный цикл
for (u, v) in E
  if d[v] > d[u] + w(u, v)
    then return False
return d
```

*Сложность алгоритма:* $O(|V| dot |E|)$

*Обоснование:* Алгоритм выполняет $|V| - 1$ итерацию основного цикла и 1 итерацию
для проверки отрицательного цикала. Внутри каждой итерации он просматривает все
$|E|$ ребер.

*Лучшее время:* $O(|E|)$
